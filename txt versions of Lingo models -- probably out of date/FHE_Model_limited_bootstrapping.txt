DATA:
	OPERATION_TYPES, LATENCY = @FILE(DDGs/random_graph5.LDT);
	OPERATIONS = @FILE(DDGs/random_graph5.LDT);
	OPERATION_IS_OF_TYPE = @FILE(DDGs/random_graph5.LDT);
	OPERATION_DEPENDENCIES = @FILE(DDGs/random_graph5.LDT);
	BOOTSTRAPPING_LATENCY = @FILE(DDGs/random_graph5.LDT);
ENDDATA

! Bootstrapping constraints defined in input file;
@FILE(DDGs/random_graph5.LDT);

DATA: !Input data specific to the limited bootstrapping model;
	CORES = @FILE(DDGs/random_graph5.LDT);
ENDDATA

@FOR( OPERATION_DEPENDENCIES(i, j) :
	FINISH_TIME(j) < START_TIME(i)
);

@FOR(OPERATIONS(i) :
	@SUM(CORES(j) : B2C(i,j)) = BOOTSTRAPPED(i)
);

@FOR(OPERATION_OPERATION_TABLE(i,j) | i #LT# j :
	! This version uses all three variables;
	! Seems to run the fastest despite the most variables and constraints;
	BOOTSTRAP_ON_SAME_CORE(i,j) = BOOTSTRAPPED(i) * BOOTSTRAPPED(j) * @PROD(CORES(k) : B2C(i,k) #EQ# B2C(j,k));
	! From the model description, it would seem #LT# should be used instead of #LE#.
		However, this caused errors for some reason, allowing one BOrder to be true
		even when the two operations had the same BOOTSTRAP_START_TIME.
		Since the third following constraint ensures two instructions cannot start
		bootstrapping on the same core at the same time anyway, it is safe to use #LE#;
	BOrder(i,j) = BOOTSTRAP_ON_SAME_CORE(i,j) * (BOOTSTRAP_START_TIME(i) #LE# BOOTSTRAP_START_TIME(j));
	BOrder(j,i) = BOOTSTRAP_ON_SAME_CORE(i,j) * (BOOTSTRAP_START_TIME(j) #LE# BOOTSTRAP_START_TIME(i));
	BOrder(i,j) + BOrder(j,i) = BOOTSTRAP_ON_SAME_CORE(i,j);


	!This version uses something like constant propogation or recalculation to eliminate the BOOTSTRAP_ON_SAME_CORE variable;
	!BOrder(i,j) = (BOOTSTRAPPED(i) * BOOTSTRAPPED(j) * @PROD(CORES(k) : B2C(i,k) #EQ# B2C(j,k))) * (BOOTSTRAP_START_TIME(i) #LE# BOOTSTRAP_START_TIME(j));
	!BOrder(j,i) = (BOOTSTRAPPED(i) * BOOTSTRAPPED(j) * @PROD(CORES(k) : B2C(i,k) #EQ# B2C(j,k))) * (BOOTSTRAP_START_TIME(j) #LE# BOOTSTRAP_START_TIME(i));
	!(BOrder(i,j) + BOrder(j,i)) = (BOOTSTRAPPED(i) * BOOTSTRAPPED(j) * @PROD(CORES(k) : B2C(i,k) #EQ# B2C(j,k)));


	!This version also eliminates the BOrder variable;
	!(BOOTSTRAPPED(i) * BOOTSTRAPPED(j) * @PROD(CORES(k) : B2C(i,k) #EQ# B2C(j,k)) * 
		(((BOOTSTRAP_START_TIME(i) #LE# BOOTSTRAP_START_TIME(j))) + (BOOTSTRAP_START_TIME(j) #LE# BOOTSTRAP_START_TIME(i)))) =
		(BOOTSTRAPPED(i) * BOOTSTRAPPED(j) * @PROD(CORES(k) : B2C(i,k) #EQ# B2C(j,k)));


	!This version eliminates BOrder only;
	!BOOTSTRAP_ON_SAME_CORE(i,j) = BOOTSTRAPPED(i) * BOOTSTRAPPED(j) * @PROD(CORES(k) : B2C(i,k) #EQ# B2C(j,k));
	!BOOTSTRAP_ON_SAME_CORE(i,j) *
		((BOOTSTRAP_START_TIME(i) #L# BOOTSTRAP_START_TIME(j)) + (BOOTSTRAP_START_TIME(j) #LE# BOOTSTRAP_START_TIME(i))) =
		BOOTSTRAP_ON_SAME_CORE(i,j);
);

@FOR(OPERATION_OPERATION_TABLE(i,j) | i #NE# j :
	BOOTSTRAP_START_TIME(j) >= FINISH_TIME(i) * BOrder(i,j);
	!This version eliminates the BOrder variable;
	!BOOTSTRAP_START_TIME(j) >= FINISH_TIME(i) * BOOTSTRAPPED(i) * BOOTSTRAPPED(j) * @PROD(CORES(k) : B2C(i,k) #EQ# B2C(j,k)) * (BOOTSTRAP_START_TIME(i) #LT# BOOTSTRAP_START_TIME(j));
);

@FOR( OPERATION_TYPE_TABLE(i, j) | OPERATION_IS_OF_TYPE(i, j) #EQ# 1: 
	BOOTSTRAP_START_TIME(i) >= START_TIME(i) + LATENCY(j)
);

@FOR(OPERATIONS(i) :
	FINISH_TIME(i) = BOOTSTRAP_START_TIME(i) + BOOTSTRAPPED(i) * BOOTSTRAPPING_LATENCY
);

min = @MAX(OPERATIONS(i) : FINISH_TIME(i));


@FOR(OPERATIONS: @BIN(BOOTSTRAPPED));
@FOR(OPERATION_CORE_TABLE: @BIN(B2C));
@FOR(OPERATION_OPERATION_TABLE: @BIN(BOOTSTRAP_ON_SAME_CORE));
@FOR(OPERATION_OPERATION_TABLE: @BIN(BOrder));
@FOR(OPERATIONS: @GIN(START_TIME));
@FOR(OPERATIONS: @GIN(BOOTSTRAP_START_TIME));
@FOR(OPERATIONS: @GIN(FINISH_TIME));

END